const std = @import("std");
const parse = @import("parse.zig");

pub fn write(fmt: parse.Format, header: anytype, reader: anytype, writer: anytype) !void {
    try writeHeader(fmt, header);
    try writeReader(fmt, reader);
    try writeWriter(fmt, writer);
}

fn writeHeader(fmt: parse.Format, out: anytype) !void {
    try writeHeaderComment(fmt, out);

    try writeStruct(fmt, out);

    try writeMemoryMethods(fmt, out);

    try out.print("int {s}_read(SDL_RWops*,{s}*);\n", .{ fmt.namespace, fmt.namespace });
    try out.print("int {s}_write(SDL_RWops*,{s});\n", .{ fmt.namespace, fmt.namespace });
}

fn writeHeaderComment(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\/*
        \\  File format: {s}
        \\  Reader & writer definitions
        \\  Generated by FFDef
        \\*/
        \\
        \\#pragma once
        \\#include <stdlib.h>
        \\#include <SDL2/SDL_rwops.h>
        \\
    , .{fmt.name});
}

fn writeStruct(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\typedef struct {s}_{{
        \\
    , .{fmt.namespace});

    for (fmt.fields) |f| {
        if (f.constraint) |c| {
            if (c.op == .Equal) {
                continue;
            }
        }
        try out.writeByte(' ');
        try writeTypePt1(out, f.typ);
        _ = try out.write(f.name);
        try writeTypePt2(out, f.typ);
        try out.writeByte(';');
        try out.writeByte('\n');
    }

    try out.writeByte('}');
    _ = try out.write(fmt.namespace);
    try out.writeByte(';');
    try out.writeByte('\n');
}

fn writeMemoryMethods(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\inline {s} new_{s}(void) {{
        \\ {s} it;
        \\ memset(&it, 0, sizeof(it));
        \\ return it;
        \\}}
        \\
    , .{ fmt.namespace, fmt.namespace, fmt.namespace });

    try out.print(
        \\inline void free_{s}({s} *it) {{
        \\
    , .{ fmt.namespace, fmt.namespace });

    for (fmt.fields) |f| {
        if (f.typ.isArray and !f.typ.arraySizeKnown) {
            try out.print(
                \\ if(it->{s} != NULL) {{
                \\  free(it->{s});
                \\ }}
                \\
            , .{ f.name, f.name });
        }
    }

    _ = try out.write(" memset(it, 0, sizeof(*it));\n}\n");
}

fn writeReader(fmt: parse.Format, out: anytype) !void {
    try writeReaderComment(fmt, out);

    try out.print(
        \\int {s}_read(SDL_RWops *src, {s} *out) {{
        \\
    , .{ fmt.namespace, fmt.namespace });

    for (fmt.fields) |f, i| {
        try writeFieldReader(out, f, i);
    }

    _ = try out.write(" return 0;\n}\n");
}

fn writeReaderComment(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\/*
        \\  File format: {s}
        \\  Reader implementation
        \\  Generated by FFDef
        \\*/
        \\
        \\#include "{s}.h"
        \\#include <string.h>
        \\
    , .{ fmt.name, fmt.namespace });
}

fn writeFieldReader(out: anytype, field: parse.Field, idx: usize) !void {
    if (field.typ.isArray) {
        if (field.typ.arraySizeKnown) {
            try out.print(
                \\ if(SDL_RWread(src, out->{s}, {d}, {d}) != {d}) {{
                \\  return -{d};
                \\ }}
                \\
            , .{
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.size,
                field.typ.arraySize.size,
                0x100 + idx,
            });
        } else {
            try out.print(
                \\ if(out->{s} > 0) {{
                \\  out->{s} = malloc({d} * out->{s});
                \\  if(SDL_RWread(src, out->{s}, {d}, out->{s}) != out->{s}) {{
                \\   return -{d};
                \\  }}
                \\ }}
                \\
            , .{
                field.typ.arraySize.ref,
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.ref,
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.ref,
                field.typ.arraySize.ref,
                0x100 + idx,
            });
        }
    } else {
        try out.print(
            \\ if(SDL_RWread(src, &out->{s}, {d}, 1) != 1) {{
            \\  return -{d};
            \\ }}
            \\
        , .{ field.name, datatypeSize(field.typ.datatype), 0x100 + idx });
    }

    if (field.constraint) |c| {
        try writeFieldConstraint(out, field, idx, c);
    }
}

fn writeFieldConstraint(out: anytype, field: parse.Field, idx: usize, cons: parse.Constraint) !void {
    if (field.typ.isArray) {
        try out.print(
            \\ if(memcmp(out->{s}, "{s}", {d}) != 0) {{
            \\  return -{d};
            \\ }}
            \\
        , .{ field.name, cons.val.str, cons.val.str.len, 0x200 + idx });
    } else {
        const operator = switch (cons.op) {
            .Equal => "!=",
            .GreaterEqual => "<",
            .LesserEqual => ">",
            .NotEqual => "==",
            .Greater => "<=",
            .Lesser => ">=",
        };
        try out.print(
            \\ if(out->{s} {s} {d}) {{
            \\  return -{d};
            \\ }}
            \\
        , .{ field.name, operator, cons.val.int, 0x200 + idx });
    }
}

fn writeWriter(fmt: parse.Format, out: anytype) !void {
    try writeWriterComment(fmt, out);

    try out.print(
        \\int {s}_write(SDL_RWops *out, {s} src) {{
        \\
    , .{ fmt.namespace, fmt.namespace });

    for (fmt.fields) |f, idx| {
        try writeFieldWriter(out, f, idx);
    }
    _ = try out.write("  return 0;\n}\n");
}

fn writeWriterComment(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\/*
        \\  File format: {s}
        \\  Writer implementation
        \\  Generated by FFDef
        \\*/
        \\
        \\#include "{s}.h"
        \\
    , .{ fmt.name, fmt.namespace });
}

fn datatypeSize(dt: parse.Datatype) usize {
    return switch (dt) {
        .Byte => 1,
        .Short => 2,
        .Int => 4,
        .Long => 8,
    };
}

fn writeFieldWriter(out: anytype, field: parse.Field, idx: usize) !void {
    // TODO do not emit struct fields for format fields that have an = constraint
    if (field.typ.isArray) {
        if (field.typ.arraySizeKnown) {
            try out.print(
                \\ if(SDL_RWwrite(out, src.{s}, {d}, {d}) != {d}) {{
                \\  return -{d};
                \\ }}
                \\
            , .{
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.size,
                field.typ.arraySize.size,
                0x100 + idx,
            });
        } else {
            try out.print(
                \\ if(SDL_RWwrite(out, src.{s}, {d}, src.{s}) != src.{s}) {{
                \\  return -{d};
                \\ }}
                \\
            , .{
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.ref,
                field.typ.arraySize.ref,
                0x100 + idx,
            });
        }
    } else {
        try out.print(
            \\ if(SDL_RWwrite(out, &src.{s}, {d}, 1) != 1) {{
            \\  return -{d};
            \\ }}
            \\
        , .{ field.name, datatypeSize(field.typ.datatype), 0x100 + idx });
    }
}

fn writeTypePt1(out: anytype, typ: parse.QualType) !void {
    if (typ.isSigned) {
        _ = try out.write("signed ");
    } else {
        _ = try out.write("unsigned ");
    }

    _ = switch (typ.datatype) {
        .Byte => try out.write("char "),
        .Short => try out.write("short "),
        .Int => try out.write("int "),
        .Long => try out.write("long long "),
    };

    if (typ.isArray and !typ.arraySizeKnown) {
        _ = try out.write("*");
    }
}

fn writeTypePt2(out: anytype, typ: parse.QualType) !void {
    if (!typ.isArray or !typ.arraySizeKnown) {
        return;
    }

    try out.print("[{d}]", .{typ.arraySize.size});
}
