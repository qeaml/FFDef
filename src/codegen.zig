const std = @import("std");
const parse = @import("parse.zig");

pub fn write(fmt: parse.Format, header: anytype, reader: anytype, writer: anytype) !void {
    try writeHeader(fmt, header);
    try writeReader(fmt, reader);
    try writeWriter(fmt, writer);
}

fn writeHeader(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\/*
        \\  File format: {s}
        \\  Reader & writer definitions
        \\  Generated by FFDef
        \\*/
        \\
        \\#include <SDL2/SDL_rwops.h>
        \\
        \\typedef struct {s}_{{
        \\
    , .{ fmt.name, fmt.namespace });

    for (fmt.fields) |f| {
        if (f.constraint) |c| {
            if (c.op == .Equal) {
                continue;
            }
        }
        try out.writeByte(' ');
        try writeTypePt1(out, f.typ);
        _ = try out.write(f.name);
        try writeTypePt2(out, f.typ);
        try out.writeByte(';');
        try out.writeByte('\n');
    }

    try out.writeByte('}');
    _ = try out.write(fmt.namespace);
    try out.writeByte(';');
    try out.writeByte('\n');

    try out.print("int {s}_read(SDL_RWops*,{s});\n", .{ fmt.namespace, fmt.namespace });
    try out.print("int {s}_write(SDL_RWops*,{s});\n", .{ fmt.namespace, fmt.namespace });
}

fn writeReader(fmt: parse.Format, out: anytype) !void {
    // TODO this
    _ = out;
    _ = fmt;
}

fn writeWriter(fmt: parse.Format, out: anytype) !void {
    try out.print(
        \\#include "{s}.h"
        \\int {s}_write(SDL_RWops *out, {s} src) {{
        \\
    , .{ fmt.namespace, fmt.namespace, fmt.namespace });

    for (fmt.fields) |f, idx| {
        try writeFieldWriter(out, f, idx);
    }
    try out.writeByte('}');
}

fn datatypeSize(dt: parse.Datatype) usize {
    return switch (dt) {
        .Byte => 1,
        .Short => 2,
        .Int => 4,
        .Long => 8,
    };
}

fn writeFieldWriter(out: anytype, field: parse.Field, idx: usize) !void {
    // TODO do not emit struct fields for format fields that have an = constraint
    if (field.typ.isArray) {
        if (field.typ.arraySizeKnown) {
            try out.print(
                \\  if(SDL_RWwrite(out, src.{s}, {d}, {d}) != {d}) {{
                \\    return -{d};
                \\  }}
                \\
            , .{
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.size,
                field.typ.arraySize.size,
                0x100 + idx,
            });
        } else {
            try out.print(
                \\  if(SDL_RWwrite(out, src.{s}, {d}, src.{s}) != src.{s}) {{
                \\    return -{d};
                \\  }}
                \\
            , .{
                field.name,
                datatypeSize(field.typ.datatype),
                field.typ.arraySize.ref,
                field.typ.arraySize.ref,
                0x100 + idx,
            });
        }
    } else {
        try out.print(
            \\  if(SDL_RWwrite(out, &src.{s}, {d}, 1) != 1) {{
            \\    return -{d};
            \\  }}
            \\
        , .{ field.name, datatypeSize(field.typ.datatype), 0x100 + idx });
    }
}

fn writeFieldConstraint(out: anytype, field: parse.Field, idx: usize, cons: parse.Constraint) !void {
    _ = idx;
    _ = field;
    _ = out;
    _ = cons;
}

fn writeTypePt1(out: anytype, typ: parse.QualType) !void {
    if (typ.isSigned) {
        _ = try out.write("signed ");
    } else {
        _ = try out.write("unsigned ");
    }

    _ = switch (typ.datatype) {
        .Byte => try out.write("char "),
        .Short => try out.write("short "),
        .Int => try out.write("int "),
        .Long => try out.write("long long "),
    };

    if (typ.isArray and !typ.arraySizeKnown) {
        _ = try out.write("*");
    }
}

fn writeTypePt2(out: anytype, typ: parse.QualType) !void {
    if (!typ.isArray or !typ.arraySizeKnown) {
        return;
    }

    try out.print("[{d}]", .{typ.arraySize.size});
}
